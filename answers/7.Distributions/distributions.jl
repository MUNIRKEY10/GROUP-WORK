# Julia code for \"Distributions\"\nusing Random\nusing Distributions\nusing Plots\nusing Statistics\nusing HypothesisTests\nusing DataFrames\nusing CSV\nusing StatsPlots # For qqplot\n\n# --- Random Number Generation ---\n# Example: rand() (equivalent to R\'s runif() without arguments)\nRandom.seed!(10) # Set seed for reproducibility\nprintln(rand(10))\nRandom.seed!(10)\nprintln(rand(10))\n\n# Linear Congruential Generator (LCG)\n# Julia doesn\'t have global mutable variables in the same way, so we\'ll use a mutable struct\nmutable struct LCGState\n  seed::UInt32 # Using UInt32 to match R\'s 2^32 modulus for the last example\n  a::UInt32\n  c::UInt32\n  m::UInt32\nend\n\nfunction next_random(lcg_state::LCGState):\n  lcg_state.seed = (lcg_state.a * lcg_state.seed + lcg_state.c) % lcg_state.m\n  return lcg_state.seed\nend\n\n# Test LCG with period 8 (a=5, c=12, m=16)\nseed_val = UInt32(10)\nlcg1_state = LCGState(seed_val, UInt32(5), UInt32(12), UInt32(16))\nout_length = 20\nvariates_lcg1 = [next_random(lcg1_state) for _ in 1:out_length]\nprintln(variates_lcg1)\n\n# Test LCG (a=131, c=7, m=16)\nseed_val = UInt32(10)\nlcg2_state = LCGState(seed_val, UInt32(131), UInt32(7), UInt32(16))\nvariates_lcg2 = [next_random(lcg2_state) for _ in 1:out_length]\nprintln(variates_lcg2)\n\n# Test LCG (a=129, c=7, m=16)\nseed_val = UInt32(10)\nlcg3_state = LCGState(seed_val, UInt32(129), UInt32(7), UInt32(16))\nvariates_lcg3 = [next_random(lcg3_state) for _ in 1:out_length]\nprintln(variates_lcg3)\n\n# Test LCG (a=1664545, c=1013904223, m=2^32)\nseed_val = UInt32(10)\nlcg4_state = LCGState(seed_val, UInt32(1664545), UInt32(1013904223), UInt32(2^32))\nvariates_lcg4 = [next_random(lcg4_state) for _ in 1:out_length]\nprintln(variates_lcg4)\n\n# --- Distributions in Julia (pdf, cdf, quantile, rand functions) ---\n# Exponential distribution: PDF and CDF\nthis_range = 0.0:0.05:8.0\n\nplt_pdf = plot(this_range, x -> pdf(Exponential(1.0), x), label=\"rate=1\", color=\"black\", linewidth=2,\n                 title=\"Exponential Distributions (PDF)\", xlabel=\"x\", ylabel=\"f(x)\", ylim=(0, 1))\nplot!(this_range, x -> pdf(Exponential(0.5), x), label=\"rate=0.5\", color=\"red\", linewidth=2)\nplot!(this_range, x -> pdf(Exponential(0.2), x), label=\"rate=0.2\", color=\"blue\", linewidth=2)\nsavefig(plt_pdf, \"exponential_pdf.pdf\")\n\nplt_cdf = plot(this_range, x -> cdf(Exponential(1.0), x), label=\"rate=1\", color=\"black\", linewidth=2,\n                 title=\"Exponential Distributions (CDF)\", xlabel=\"x\", ylabel=\"P(X<x)\", ylim=(0, 1))\nplot!(this_range, x -> cdf(Exponential(0.5), x), label=\"rate=0.5\", color=\"red\", linewidth=2)\nplot!(this_range, x -> cdf(Exponential(0.2), x), label=\"rate=0.2\", color=\"blue\", linewidth=2)\nsavefig(plt_cdf, \"exponential_cdf.pdf\")\n\n# --- Fitting Distributional Models ---\n# Method of Moments: Closed form (Gamma Distribution Example)\nfunction gamma_est_MM(x)\n  m = mean(x)\n  v = var(x) # By default, var in Julia is sample variance (ddof=1)\n  shape = m^2 / v\n  scale = v / m # In Julia Distributions.jl, Gamma(shape, scale) uses scale, not rate\n  return (shape=shape, scale=scale)\nend\n\n# Method of Moments: Numerically (Discrepancy function)\ngamma_mean_func(shape, scale) = shape * scale\ngamma_var_func(shape, scale) = shape * scale^2\n\nfunction gamma_discrepancy(params, x)\n  shape, scale = params\n  return (mean(x) - gamma_mean_func(shape, scale))^2 + (var(x) - gamma_var_func(shape, scale))^2\nend\n\n# --- Maximum Likelihood Estimation ---\n# Example: Cat heart weights (Creating a dummy cats dataframe similar to R\'s MASS::cats)\ncats_julia = DataFrame(Sex = vcat(fill(\"F\", 73), fill(\"M\", 71)),\n                         Bwt = randn(144) .* 0.5 .+ 2.72,\n                         Hwt = randn(144) .* 3.0 .+ 10.63)\n
plt_hist_hwt = histogram(cats_julia.Hwt, bins=15, normalize=:pdf, label=\"Empirical Density (Histogram)\",\n                            title=\"Histogram of Cat Heart Weights\", xlabel=\"Heart Weight\")\nsavefig(plt_hist_hwt, \"cats_hwt_hist.pdf\")\n\n# Using fit_mle for MLE from Distributions.jl\n# For Gamma distribution, fit_mle returns shape and scale directly\nmle_gamma_dist = fit_mle(Gamma, cats_julia.Hwt)\ncats_mle_gamma = (shape = Distributions.shape(mle_gamma_dist), scale = Distributions.scale(mle_gamma_dist))\nprintln(\"MLE Gamma Parameters (shape, scale):\", cats_mle_gamma)\n\n# Using Method of Moments estimates for comparison\ncats_gamma_mm = gamma_est_MM(cats_julia.Hwt)\nprintln(\"MM Gamma Parameters (shape, scale):\", cats_gamma_mm)\n\n# Checking the fit: QQ Plot\n# StatsPlots.qqplot for Gamma distribution\nplt_qq_mm = qqplot(Gamma(cats_gamma_mm.shape, cats_gamma_mm.scale), cats_julia.Hwt,\n                      label=\"Gamma (MM)\", title=\"QQ Plot: Cat Heart Weights vs. Gamma (MM)\",\n                      xlabel=\"Theoretical Gamma Quantiles\", ylabel=\"Observed Heart Weight\")\nplot!(plt_qq_mm, [0, 25], [0, 25], label=\"Ideal (y=x)\", color=\"red\", linestyle=:dash)\nsavefig(plt_qq_mm, \"cats_hwt_qqplot_gamma.pdf\")\n\nplt_qq_mle = qqplot(Gamma(cats_mle_gamma.shape, cats_mle_gamma.scale), cats_julia.Hwt,\n                       label=\"Gamma (MLE)\", title=\"QQ Plot: Cat Heart Weights vs. Gamma (MLE)\",\n                       xlabel=\"Theoretical Gamma Quantiles\", ylabel=\"Observed Heart Weight\")\nplot!(plt_qq_mle, [0, 25], [0, 25], label=\"Ideal (y=x)\", color=\"blue\", linestyle=:dash)\nsavefig(plt_qq_mle, \"cats_hwt_qqplot_gamma_mle.pdf\")\n\n# Checking the fit: Density plot overlay\nplt_density_overlay = plot(plt_hist_hwt, label=\"Empirical Density (Histogram)\", legend=:topright)\nplot!(plt_density_overlay, this_range, x -> pdf(Gamma(cats_gamma_mm.shape, cats_gamma_mm.scale), x),\n      label=\"Gamma (MM)\", color=\"red\", linestyle=:dash, linewidth=2)\nplot!(plt_density_overlay, this_range, x -> pdf(Gamma(cats_mle_gamma.shape, cats_mle_gamma.scale), x),\n      label=\"Gamma (MLE)\", color=\"blue\", linestyle=:dot, linewidth=2)\nplot!(plt_density_overlay, title=\"Density of Cat Heart Weights with Gamma Fit\", xlabel=\"Heart Weight\")\nsavefig(plt_density_overlay, \"cats_hwt_density_gamma.pdf\")\n\n# Checking the fit: Calibration plots (ECDF of theoretical CDF)\nfunction calibration_plot(data, dist, title, filename)\n  # Calculate theoretical CDF values for each data point\n  theoretical_cdf_values = cdf.(dist, data)\n  # Calculate empirical CDF of these theoretical CDF values\n  sorted_cdf_values = sort(theoretical_cdf_values)\n  ecdf_values = (1:length(sorted_cdf_values)) / length(sorted_cdf_values)\n\n  plt = plot(sorted_cdf_values, ecdf_values, seriestype=:line, markersize=2, label=\"Empirical CDF of Theoretical CDF\",\n             title=title, xlabel=\"Theoretical Cumulative Probability\", ylabel=\"Observed Cumulative Proportion\")\n  plot!(plt, [0, 1], [0, 1], color=\"grey\", linestyle=:dash, label=\"Ideal Calibration (y=x)\")\n  savefig(plt, filename)\nend\n\n# MM Calibration Plot\ncalibration_plot(cats_julia.Hwt, Gamma(cats_gamma_mm.shape, cats_gamma_mm.scale),\n                 \"Calibration Plot for Cat Heart Weights (MM)\", \"cats_hwt_calibration_gamma_mm.pdf\")\n\n# MLE Calibration Plot\ncalibration_plot(cats_julia.Hwt, Gamma(cats_mle_gamma.shape, cats_mle_gamma.scale),\n                 \"Calibration Plot for Cat Heart Weights (MLE)\", \"cats_hwt_calibration_gamma_mle.pdf\")\n\n# --- Kolmogorov-Smirnov test ---\n# One-sample KS test (against a theoretical distribution)\n# ExactOneSampleKSTest requires the distribution object\nks_test_one_sample_julia = ExactOneSampleKSTest(cats_julia.Hwt, Gamma(cats_mle_gamma.shape, cats_mle_gamma.scale))\nprintln(\"One-sample KS test (MLE Gamma):\", ks_test_one_sample_julia)\n\n# Two-sample KS test (between two samples)\nRandom.seed!(42)\nx_norm_julia = rand(Normal(0, 1), 100)\ny_norm_julia = rand(Normal(0.5, 1), 100)\nks_test_two_sample_julia = ApproximateTwoSampleKSTest(x_norm_julia, y_norm_julia)\nprintln(\"Two-sample KS test (Normal samples):\", ks_test_two_sample_julia)\n\n# --- Chi-squared test ---\n# Chi-squared test for categorical data\nM_julia = DataFrame(gender = categorical([\"F\", \"M\"]), \n                       Democrat = [762, 484], \n                       Independent = [327, 239], \n                       Republican = [468, 477]))\n\n# Convert DataFrame to a Matrix for chisq.test if needed, or use the dataframe directly with its column names\n# For HypothesisTests.jl, it often expects a matrix for contingency tables\nM_matrix = Matrix(M_julia[:, 2:end])\nchisq_test_categorical_julia = ChisqTest(M_matrix)\nprintln(M_julia)\nprintln(\"Chi-squared test (categorical):\", chisq_test_categorical_julia)\n\n# Chi-squared test for continuous distributions\n# First, get histogram bins and counts\nhist_counts_julia, hist_bins_julia = histogram(cats_julia.Hwt, bins=8, plot=false).counts, histogram(cats_julia.Hwt, bins=8, plot=false).edges[1]\nprintln(\"Histogram Breaks:\", hist_bins_julia)\nprintln(\"Histogram Counts:\", hist_counts_julia)\n\n# Calculate theoretical probabilities for bins using MLE parameters\ncum_probs_julia = cdf.(Gamma(cats_mle_gamma.shape, cats_mle_gamma.scale), hist_bins_julia)\n# The probability of each bin is the difference between consecutive cumulative probabilities\np_theoretical_bins_julia = diff(cum_probs_julia)\n\n# Ensure no zero probabilities or counts for chi-squared test. Filter out bins with zero expected values.\nmin_prob_threshold = 1e-10\nvalid_mask_julia = p_theoretical_bins_julia .> min_prob_threshold\nadjusted_hist_counts_julia = hist_counts_julia[valid_mask_julia]\nadjusted_p_theoretical_bins_julia = p_theoretical_bins_julia[valid_mask_julia]\n\n# Normalize adjusted theoretical probabilities to sum to 1\nadjusted_p_theoretical_bins_julia = adjusted_p_theoretical_bins_julia / sum(adjusted_p_theoretical_bins_julia)\n\n# Perform Chi-squared test (GoodnessOfFitTest for goodness-of-fit)\n# ddof is similar to R\'s df adjustment for estimated parameters. For 2 parameters, ddof=2.\n# Julia\'s GoodnessOfFitTest calculates degrees of freedom automatically if you provide the number of parameters subtracted\nif length(adjusted_hist_counts_julia) > 2\n  chisq_test_continuous_julia = GoodnessOfFitTest(adjusted_hist_counts_julia, Categorical(adjusted_p_theoretical_bins_julia); n_parameters_estimated=2)\n  println(\"Chi-squared test (continuous, adjusted df):\", chisq_test_continuous_julia)\nelse\n  println(\"Not enough valid bins or degrees of freedom for Chi-squared test after adjustment.\")\nend\n